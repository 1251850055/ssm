1.多线程
	进程:正在运行的程序，是程序动态的执行过程
	线程:在进程内部，并发运行的过程
	并发:进程是并发运行的，操作系统将时间划分了很多个时间片段,
			尽可能的均匀分配给正在执行的程序;微观上进程是走走停停
			,宏观上都在运行中,这种都运行的现象就叫做并发,并发不是绝对
			意义上的"同时"。
			
	2.要实现一个线程:
		a.需要继承Thread类，实现步骤:
			1)继承Thread类，覆盖run()方法，并提供并发运行的过程。
			2)创建这个类的实例
			3)使用start()方法启动这个线程
			
		b.实现Runnable接口 实现步骤:		
		 	1)Runnable接口，并实现run()方法，提供并发运行的过程
		 	2)创建这个类的实例，用这个实例作为这个Thread构造参数
		 	3)使用start()方法启动这个线程
		 	
		 	 
	3.线程的状态(五中状态)	 	
		 	1.新建状态
		 	2.准备运行状态
		 	3.运行状态
		 	4.阻塞(Block)状态
		 	5.Dead(死亡状态)
		 	
		1)、New(新建状态),当线程使用New创建一个线程后，该线程就处于
				新建状态,此时线程还未启动,当线程被调用start()方法时,线程才会启动。
		2)、Runnable(可以运行的状态(就绪状态):表示线程准备就绪),等待CPU执行
		3)、Running(正在运行的状态):
			1.假如该线程获取了CPU,则进去Running状态,开始执行线程体，
				run()方法中的内容
			2.如果系统只有一个CPU,那么任意时间点则只有1条线程
				处于running状态,如果双核的,则同一点则有两条线程
				处于Running状态	
			3.当一条线程开始运行时,如果他不是一瞬间完成，那么它不可能一直
				在Running状态	
				(系统会给每个可执行的线程一小段时间来处理任务，当时间段用完，
				系统会剥夺该线程所占的资源，让其它线程获得运行的机会)
			4.	join()方法使当前线程暂停执行，等待调用该方法的线程结束后再执行本线程。
			5.调用yueld方法，可以使线程由Running状态 进入Runnable
		4)、Block(阻塞状态)(挂起) Scanner  wait()  sleep()
			线程调用sleep方法 主动放弃所占cpu资源
		5)、死亡状态(Dead)
			当线程的run()方法结束时，线程进去该状态
			注:不要试图对一个已经进入死亡状态的线程调用
				 start()方法，线程死亡后，将不能再次作为线程执行。
				 
				 
				 
 sleep													与yield()         区别
 1.使当前线程进入被阻塞状态  			将线程转入暂停状态
 2.及时没有其他等待运行的线程			没有其他等待运行的线程
 	当前线程夜壶等待 指定的时间			该线程马上恢复执行
 3.其他等待执行的线程的机会				会将优先级相同或者
 	都是均等的										更高的线程运行
 	
 	
 	wait()  挂起当前的线程，进入阻塞状态
 	notify()  从等待序列中唤醒一个线程
 	notifyAll();    把所有等待的线程都唤醒
 	
 	1.作用 用线程实现   奇数  偶数 两个线程的输出
 	2. 红绿灯 用线程实现  
 	
 	
 	
 	
 	
 	
				 	
			
			
				
	
	 
